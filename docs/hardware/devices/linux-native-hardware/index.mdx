---
id: linux-native-hardware
title: Meshtastic on Linux-Native Devices
sidebar_label: Linux Native Devices
sidebar_position: 11
description: Set up and configure Meshtastic on Linux-native devices using the meshtasticd binary.
---

The device software can also run on a native Linux devices thanks to the [Portduino framework](https://github.com/geeksville/framework-portduino).

The application either simulates some of the interfaces, or uses the real hardware of your machine.

Device firmware from 1.3.42 and on even allows you to simulate the LoRa chip by sending and receiving Meshtastic packets via a local TCP port.
In this way, you can let multiple instances of the application communicate with each other as if they did via LoRa.

For an example on how to use it, see the [interactive simulator](https://github.com/GUVWAF/Meshtasticator/blob/master/INTERACTIVE_SIM.md) that also emulates a wireless environment using simulated positions of the nodes.

## Prerequisites and Hardware Compatibility

Before proceeding with the setup, ensure the device meets the following requirements:

### Tested Devices
- Raspberry Pi zero, zero 2 , 3,4, Pi 400, and Pi 5.[^1]
- Ubuntu 22.04 X86_64 with a CH341-SX1262 DIY dongle.[^2]
- Debian GNU/Linux trixie/sid riscv64 on Cvitek CV180X ASIC, C906 (Milk-V Duo), on the SPI bus.

### Hardware Compatibility

:::caution Warning
UART HATs and SX1302/SX1303 chip-based HATs are not supported. Only hats that use a SPI radio can work with Meshtastic.
:::

- Tested radios include the Waveshare SX126X (SPI version), Adafruit RFM9x, and Elecrow Lora RFM95 IOT.
- Support for I2C displays, SPI displays, and keyboard input has been confirmed. It is necessary to be aware of potential pin conflicts when stacking hats.

## Usage

The easiest way of building the native application is using Visual Studio Code with the PlatformIO extension.
See the instructions for creating such a building environment [here](/docs/development/firmware/build).

Then after opening the firmware repository in Visual Studio Code, simply click on the PlatformIO extension in the left bar, select native and click on 'Build'.
This will generate the binary file 'program' which you can find in `.pio/build/native/`.
Once in this directory or when you copied the file to your current directory, launch the application with `./program`.

Additional arguments can be given to the program, which are listed as follows:

- `-d DIRECTORY`: The directory to use as the virtual filesystem (VFS).
- `-e`: Erase the virtual filesystem before use.
- `-h MAC_ADDRESS`: The MAC address to assign to this virtual machine.
- `-p TCP_PORT`: The local TCP port to use for running the Meshtastic API.


## Using the CLI

To use Python CLI against exposed TCP port 4403,
type this in the host machine:

`meshtastic --info --host localhost`

While you can interact with it in the same way as a normal device using a client that supports TCP connections, the application has its limitations. For example, rebooting is not implemented, so for some settings to apply you have to restart the application.


[^1]: While the Raspberry Pi Zero has been tested with meshtasticd, building as a native ARM32 binary has proven challenging. As a workaround, consider building on a Raspberry Pi 4 or 5 with a 32-bit OS and copying the output file to the Pi Zero.
[^2]: **Limited Functionality with CH341-SX1262 Device:** Please be aware that the CH341-SX1262 device is currently experiencing partial functionality issues. For reasons yet to be determined, this device struggles with sending packets larger than a few bytes.

